<!DOCTYPE html>
<html>
<head>
    

    

    



    <meta charset="utf-8">
    
    
    
    
    <title>Python多进程与多线程 | Yzzz011125&#39;s Blog | 学习超车超近道的Yz</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    
    <meta name="theme-color" content="#3F51B5">
    
    
    <meta name="keywords" content="Python,Python爬虫">
    <meta name="description" content="Python多进程与多线程  （1）、多进程进程是程序在计算机上的一次执行活动。当你运行一个程序，你就启动了一个进程。凡是用于完成操作系统的各种功能的进程就是系统进程，而所有由你启动的进程都是用户进程。同理，多进程就是指计算机同时执行多个进程，一般是同时运行多个软件。 multiprocessing类似于threading模块支持生成进程的包，是Python的标准模块，它既可以用来编写多进程，也可">
<meta property="og:type" content="article">
<meta property="og:title" content="Python多进程与多线程">
<meta property="og:url" content="http://yoursite.com/2020/02/10/Python%E5%A4%9A%E8%BF%9B%E7%A8%8B%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B/index.html">
<meta property="og:site_name" content="Yzzz011125&#39;s Blog">
<meta property="og:description" content="Python多进程与多线程  （1）、多进程进程是程序在计算机上的一次执行活动。当你运行一个程序，你就启动了一个进程。凡是用于完成操作系统的各种功能的进程就是系统进程，而所有由你启动的进程都是用户进程。同理，多进程就是指计算机同时执行多个进程，一般是同时运行多个软件。 multiprocessing类似于threading模块支持生成进程的包，是Python的标准模块，它既可以用来编写多进程，也可">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://raw.githubusercontent.com/Yzzz011125/Yzzz011125.github.io/master/img/PythonSpider-image/Thread.png">
<meta property="article:published_time" content="2020-02-10T06:31:18.000Z">
<meta property="article:modified_time" content="2020-05-14T00:45:21.004Z">
<meta property="article:author" content="Yzzz011125">
<meta property="article:tag" content="Python">
<meta property="article:tag" content="Python爬虫">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://raw.githubusercontent.com/Yzzz011125/Yzzz011125.github.io/master/img/PythonSpider-image/Thread.png">
    
    <link rel="shortcut icon" href="/img/favicon.ico">
    <link rel="stylesheet" href="//unpkg.com/hexo-theme-material-indigo@latest/css/style.css">
    <script>window.lazyScripts=[]</script>

    <!-- custom head -->
    

<meta name="generator" content="Hexo 4.2.0"></head>

<body>
    <div id="loading" class="active"></div>

    <aside id="menu" class="hide" >
  <div class="inner flex-row-vertical">
    <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menu-off">
        <i class="icon icon-lg icon-close"></i>
    </a>
    <div class="brand-wrap" style="background-image:url(/img/brand.jpg)">
      <div class="brand">
        <a href="https://github.com/Yzzz011125" target="_blank" rel="noopener" class="avatar waves-effect waves-circle waves-light">
          <img src="/img/face.jpg">
        </a>
        <hgroup class="introduce">
          <h5 class="nickname">Yzzz011125</h5>
          <a href="mailto:1043357338@qq.com" title="1043357338@qq.com" class="mail">1043357338@qq.com</a>
        </hgroup>
      </div>
    </div>
    <div class="scroll-wrap flex-col">
      <ul class="nav">
        
            <li class="waves-block waves-effect">
              <a href="/"  >
                <i class="icon icon-lg icon-home"></i>
                Home
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/archives"  >
                <i class="icon icon-lg icon-archives"></i>
                Archives
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/tags"  >
                <i class="icon icon-lg icon-tags"></i>
                Tags
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="https://github.com/Yzzz011125" target="_blank" >
                <i class="icon icon-lg icon-github"></i>
                Github
              </a>
            </li>
        
      </ul>
    </div>
  </div>
</aside>

    <main id="main">
        <header class="top-header" id="header">
    <div class="flex-row">
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light on" id="menu-toggle">
          <i class="icon icon-lg icon-navicon"></i>
        </a>
        <div class="flex-col header-title ellipsis">Python多进程与多线程</div>
        
        <div class="search-wrap" id="search-wrap">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="back">
                <i class="icon icon-lg icon-chevron-left"></i>
            </a>
            <input type="text" id="key" class="search-input" autocomplete="off" placeholder="Search">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="search">
                <i class="icon icon-lg icon-search"></i>
            </a>
        </div>
        
        
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menuShare">
            <i class="icon icon-lg icon-share-alt"></i>
        </a>
        
    </div>
</header>
<header class="content-header post-header">

    <div class="container fade-scale">
        <h1 class="title">Python多进程与多线程</h1>
        <h5 class="subtitle">
            
                <time datetime="2020-02-10T06:31:18.000Z" itemprop="datePublished" class="page-time">
  2020-02-10
</time>


            
        </h5>
    </div>

    


</header>


<div class="container body-wrap">
    
    <aside class="post-widget">
        <nav class="post-toc-wrap post-toc-shrink" id="post-toc">
            <h4>TOC</h4>
            <ol class="post-toc"><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#Python多进程与多线程"><span class="post-toc-text">Python多进程与多线程</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#（1）、多进程"><span class="post-toc-text">（1）、多进程</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#（2）、多线程"><span class="post-toc-text">（2）、多线程</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#（3）、多进程与多线程的选择和区别"><span class="post-toc-text">（3）、多进程与多线程的选择和区别</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#（4）、并行、并发、高并发等概念"><span class="post-toc-text">（4）、并行、并发、高并发等概念</span></a></li></ol></li></ol></li></ol>
        </nav>
    </aside>


<article id="post-Python多进程与多线程"
  class="post-article article-type-post fade" itemprop="blogPost">

    <div class="post-card">
        <h1 class="post-card-title">Python多进程与多线程</h1>
        <div class="post-meta">
            <time class="post-time" title="2020-02-10 14:31:18" datetime="2020-02-10T06:31:18.000Z"  itemprop="datePublished">2020-02-10</time>

            


            

        </div>
        <div class="post-content" id="post-content" itemprop="postContent">
            <h1 id="Python多进程与多线程"><a href="#Python多进程与多线程" class="headerlink" title="Python多进程与多线程"></a>Python多进程与多线程</h1><br/>

<h3 id="（1）、多进程"><a href="#（1）、多进程" class="headerlink" title="（1）、多进程"></a>（1）、多进程</h3><p><strong>进程</strong>是程序在计算机上的一次执行活动。当你运行一个程序，你就启动了一个进程。凡是用于完成操作系统的各种功能的进程就是系统进程，而所有由你启动的进程都是用户进程。同理，多进程就是指计算机同时执行多个进程，一般是同时运行多个软件。</p>
<p>multiprocessing类似于threading模块支持生成进程的包，是Python的标准模块，它既可以用来编写多进程，也可以用来编写多线程。如果是多线程的话，用multiprocessing.dummy即可，用法与multiprocessing基本相同。由于python使用全局解释器锁(GIL)，他会将进程中的线程序列化，也就是多核cpu实际上并不能达到并行提高速度的目的，而使用多进程则是不受限的，所以实际应用中都是推荐多进程的。</p>
<p>如果每个子进程执行需要消耗的时间非常短（执行+1操作等），这不必使用多进程，因为进程的启动关闭也会耗费资源。当然使用多进程往往是用来处理CPU密集型（科学计算）的需求，如果是IO密集型（文件读取，爬虫等）则可以使用多线程去处理。</p>
<p><code>multiprocessing</code>多进程详解在<a href="https://blog.csdn.net/brucewong0516/article/details/85776194" target="_blank" rel="noopener">这里</a><del>~</del></p>
<p>1、<code>multiprocessing</code>常用组件及功能</p>
<br/>

<p>1.1、管理进程模块</p>
<ul>
<li>Process（用于创建进程模块） </li>
<li>Pool（用于创建管理进程池）</li>
<li>Queue（用于进程通信，资源共享）</li>
<li>Value，Array（用于进程通信，资源共享）</li>
<li>Pipe（用于管道通信）</li>
<li>Manager（用于资源共享）</li>
</ul>
<p>1.2、同步子进程模块</p>
<ul>
<li>Condition</li>
<li>Event</li>
<li>Lock</li>
<li>RLock</li>
<li>Semaphore</li>
</ul>
<br/>

<p>2、Process类</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">multiprocessing</span>.<span class="title">Process</span><span class="params">(group=None, target=None, name=None, \</span></span></span><br><span class="line"><span class="class"><span class="params">                              args=<span class="params">()</span>, kwargs=&#123;&#125;, *, daemon=None)</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li>Process模块用来创建子进程，是Multiprocessing核心模块，使用方式与Threading类似，可以实现多进程的创建，启动，关闭等操作。 </li>
<li>一般需要传入target目标函数，args函数的参数 </li>
</ul>
<p>2.1、run（）</p>
<p>​     表示进程运行的方法。可以在子类中重写此方法。标准run() 方法调用传递给对象构造函数的可调用对象作为目标参数（如果有），分别使用args和kwargs参数中的顺序和关键字参数。 </p>
<p>2.2、start（）</p>
<p>​     进程准备就绪，等待CPU调度。 </p>
<p>2.3、join（[超时]）</p>
<p>​     如果可选参数timeout是None，则该方法将阻塞，直到join()调用其方法的进程终止。如果timeout是一个正数，它最多会阻塞超时秒。请注意，None如果方法的进程终止或方法超时，则返回该方法。检查进程exitcode以确定它是否终止。 </p>
<p>2.4、name</p>
<p>​     进程的名称。该名称是一个字符串，仅用于识别目的。 </p>
<p>2.5、is_alive（）</p>
<p>​     返回进程是否存活。从start() 方法返回到子进程终止的那一刻，进程对象仍处于活动状态。 </p>
<p>2.6、daemon</p>
<p>​     进程的守护进程标志，一个布尔值。必须在start()调用之前设置，当进程退出时，它会尝试终止其所有守护进程子进程。 </p>
<p>2.7、pid</p>
<p>​     返回进程ID。在产生该过程之前，这将是 None。 </p>
<p>2.8、exitcode</p>
<p>​     子进程的退出代码。None如果流程尚未终止，这将是。负值-N表示孩子被信号N终止。 </p>
<p><strong>需要注意的是start()，join()，is_alive()， terminate()和exitcode方法只能由创建进程对象的过程调用。</strong></p>
<p>一些方法的示例用法Process</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">info</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'module name:'</span>, __name__)</span><br><span class="line">    print(<span class="string">'parent process:'</span>, os.getppid())</span><br><span class="line">    print(<span class="string">'process id:'</span>, os.getpid())</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(name)</span>:</span></span><br><span class="line">    info()</span><br><span class="line">    time.sleep(<span class="number">3</span>)</span><br><span class="line">    print(<span class="string">'hello'</span>, name)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    info()</span><br><span class="line">    p = Process(target=f, args=(<span class="string">'bob'</span>,))</span><br><span class="line">    <span class="comment"># p.daemon = False   如果想要守护主进程，设定p.daemon = True</span></span><br><span class="line">    print(p.daemon)</span><br><span class="line">    p.start()</span><br><span class="line">    p.join(<span class="number">1</span>)</span><br><span class="line">    print(<span class="string">'name:'</span>, p.name)</span><br><span class="line">    print(<span class="string">'is_alive:'</span>, p.is_alive())</span><br><span class="line">    print(<span class="string">'exitcode:'</span>, p.exitcode)</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">------------------------------------------------------------</span></span><br><span class="line"><span class="string">module name: __main__</span></span><br><span class="line"><span class="string">parent process: 1188</span></span><br><span class="line"><span class="string">process id: 13060</span></span><br><span class="line"><span class="string">False</span></span><br><span class="line"><span class="string">module name: __mp_main__</span></span><br><span class="line"><span class="string">parent process: 13060</span></span><br><span class="line"><span class="string">process id: 13424</span></span><br><span class="line"><span class="string">name: Process-1</span></span><br><span class="line"><span class="string">is_alive: True</span></span><br><span class="line"><span class="string">exitcode: None</span></span><br><span class="line"><span class="string">hello bob</span></span><br><span class="line"><span class="string">------------------------------------------------------------</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>



<p><strong>在上述逻辑中，子进程会休息3s然后再打印一句话才结束，同时设定join(1)阻塞1s，阻塞在1s后结束，我们的并没有守护主进程，然后主进程结束后，子进程依然alive；</strong></p>
<br/>

<p>3、示例</p>
<p>3.1、事先说明</p>
<p> 有两点在写代码时需要注意</p>
<ul>
<li>使用多进程时，最好在文件中编写代码，用cmd来执行，在jupyter经常无法得到想要的结果 </li>
<li>创建进程的代码一定要放在<code>if __name__ == &#39;__main__&#39;</code>里面 </li>
</ul>
<br/>



<p>3.2、最简单的多进程</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> multiprocessing <span class="comment"># 多进程</span></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">myfun</span><span class="params">(num)</span>:</span></span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line">    print(num + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">        p = multiprocessing.Process(target = myfun, args = (i, )) <span class="comment"># 声明线程对象</span></span><br><span class="line">        p.start() <span class="comment"># 开启线程</span></span><br></pre></td></tr></table></figure>

<br/>



<p>3.3、类的形式</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyProcess</span><span class="params">(multiprocessing.Process)</span>:</span> <span class="comment"># 继承多线程中的Process</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, i)</span>:</span></span><br><span class="line">        multiprocessing.Process.__init__(self)</span><br><span class="line">        self.i = i</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        url = <span class="string">'https://movie.douban.com/top250?start=&#123;&#125;&amp;filter='</span>.format(self.i*<span class="number">25</span>)</span><br><span class="line">        r = requests.get(url)</span><br><span class="line">        soup = BeautifulSoup(r.content, <span class="string">'html.parser'</span>)</span><br><span class="line">        lis = soup.find(<span class="string">'ol'</span>, class_=<span class="string">'grid_view'</span>).find_all(<span class="string">'li'</span>)</span><br><span class="line">        <span class="keyword">for</span> li <span class="keyword">in</span> lis:</span><br><span class="line">            title = li.find(<span class="string">'span'</span>, class_=<span class="string">"title"</span>).text</span><br><span class="line">            print(title)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">        p = MyProcess(i)</span><br><span class="line">        p.start()</span><br></pre></td></tr></table></figure>

<br/>



<p>3.4、进程池</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Pool, current_process</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_title</span><span class="params">(i)</span>:</span></span><br><span class="line">    print(<span class="string">'start'</span>, current_process().name)</span><br><span class="line">    title_list = []</span><br><span class="line">    url = <span class="string">'https://movie.douban.com/top250?start=&#123;&#125;&amp;filter='</span>.format(i*<span class="number">25</span>)</span><br><span class="line">    r = requests.get(url)</span><br><span class="line">    soup = BeautifulSoup(r.content, <span class="string">'html.parser'</span>)</span><br><span class="line">    lis = soup.find(<span class="string">'ol'</span>, class_=<span class="string">'grid_view'</span>).find_all(<span class="string">'li'</span>)</span><br><span class="line">    <span class="keyword">for</span> li <span class="keyword">in</span> lis:</span><br><span class="line">        title = li.find(<span class="string">'span'</span>, class_=<span class="string">"title"</span>).text</span><br><span class="line">        <span class="comment"># return title</span></span><br><span class="line">        title_list.append(title)</span><br><span class="line">        print(title)</span><br><span class="line">    <span class="keyword">return</span>(title_list)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    pool = Pool()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">        pool.apply_async(get_title, (i, ))</span><br><span class="line">    pool.close()</span><br><span class="line">    pool.join()</span><br><span class="line">    print(<span class="string">'finish'</span>)</span><br></pre></td></tr></table></figure>

<p> 这里要说明一下</p>
<ul>
<li>使用<code>Pool</code>时，不指定进程数量，则默认为CPU核心数量 </li>
<li>核心数量对应电脑的（任务管理器-性能）逻辑处理器数量而不是内核数量（我的电脑2个内核，有4个逻辑处理器，所以这里默认使用4个进程）</li>
<li>进程数量可以是成百上千，并不是说最大开启进程数量为4，只要用<code>Pool(10)</code>就可以同时开启10个进程进行抓取 </li>
<li>不过要注意一点，无论多线程还是多进程，数量开启太多都会造成切换费时，降低效率，所以慎重创建太多线程与进程 </li>
</ul>
<br/>



<p>3.5、进程之间内存独立</p>
<p>多进程与多线程最大的不同在于，多进程的每一个进程都有一份变量的拷贝，进程之间的操作互不影响，我们先来看看下面的例子 </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">zero = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">change_zero</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">global</span> zero</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>):</span><br><span class="line">        zero = zero + <span class="number">1</span></span><br><span class="line">        print(multiprocessing.current_process().name, zero)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    p1 = multiprocessing.Process(target = change_zero)</span><br><span class="line">    p2 = multiprocessing.Process(target = change_zero)</span><br><span class="line">    p1.start()</span><br><span class="line">    p2.start()</span><br><span class="line">    p1.join()</span><br><span class="line">    p2.join()</span><br><span class="line">    print(zero)</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    运行如下：</span></span><br><span class="line"><span class="string">    Process-1 1</span></span><br><span class="line"><span class="string">    Process-1 2</span></span><br><span class="line"><span class="string">    Process-1 3</span></span><br><span class="line"><span class="string">    Process-2 1</span></span><br><span class="line"><span class="string">    Process-2 2</span></span><br><span class="line"><span class="string">    Process-2 3</span></span><br><span class="line"><span class="string">    0</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    '''</span></span><br></pre></td></tr></table></figure>

<p>上面结果显示，新创建的两个进程各自把值增加到了3，二者不是一起将其加到了6的。同时，主进程的值还是0。所以说每个进程都是将数据拷贝过去自己做，并没有将结果与其他进程共享。</p>
<p>但是对于写入文件则不同</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">write_file</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">30</span>):</span><br><span class="line">        <span class="keyword">with</span> open(<span class="string">'try.txt'</span>, <span class="string">'a'</span>) <span class="keyword">as</span> f:</span><br><span class="line">            f.write(str(i) + <span class="string">' '</span>)</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    p1 = multiprocessing.Process(target = write_file)</span><br><span class="line">    p2 = multiprocessing.Process(target = write_file)</span><br><span class="line">    p1.start()</span><br><span class="line">    p2.start()</span><br><span class="line">    p1.join()</span><br><span class="line">    p2.join()</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    得到的try.txt文件内容如下</span></span><br><span class="line"><span class="string">    0 1 2 3 4 5 6 ... 29</span></span><br><span class="line"><span class="string">    '''</span></span><br></pre></td></tr></table></figure>

<p>可见两个进程都将数据写入了同一份文件中。</p>
<p>下面我们要讨论第一种情况，如果真的要在两个进程之间共享变量需要怎么办</p>
<p>使用<code>队列</code>和<code>pipe</code></p>
<br/>



<p>3.6、队列</p>
<p>这里介绍进程之间的第一种交流方式——队列。<code>multiprocessing</code>模块中提供了<code>multiprocessing.Queue</code>，它和<code>Queue.Queue</code>的区别在于，它里面封装了进程之间的数据交流，不同进程可以操作同一个<code>multiprocessing.Queue</code>。 </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process, Queue</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">addone</span><span class="params">(q)</span>:</span></span><br><span class="line">    q.put(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">addtwo</span><span class="params">(q)</span>:</span></span><br><span class="line">    q.put(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    q = Queue()</span><br><span class="line">    p1 = Process(target=addone, args = (q, ))</span><br><span class="line">    p2 = Process(target=addtwo, args = (q, ))</span><br><span class="line">    p1.start()</span><br><span class="line">    p2.start()</span><br><span class="line">    p1.join()</span><br><span class="line">    p2.join()</span><br><span class="line">    print(q.get())</span><br><span class="line">    print(q.get())</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    运行结果如下</span></span><br><span class="line"><span class="string">    1</span></span><br><span class="line"><span class="string">    2</span></span><br><span class="line"><span class="string">    '''</span></span><br></pre></td></tr></table></figure>

<p> 这个队列是线程、进程安全的，即对队列的每一次修改中间不会被中断从而造成结果错误。 </p>
<br/>



<p>3.7、pipe</p>
<p><code>pipe</code>的功能和<code>Queue</code>类似，可以理解成简化版的<code>Queue</code>。我们先来看下面一个例子 </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process, Pipe, current_process</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">produce</span><span class="params">(conn)</span>:</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        new = random.randint(<span class="number">0</span>, <span class="number">100</span>)</span><br><span class="line">        print(<span class="string">'&#123;&#125; produce &#123;&#125;'</span>.format(current_process().name, new))</span><br><span class="line">        conn.send(new)</span><br><span class="line">        time.sleep(random.random())</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">consume</span><span class="params">(conn)</span>:</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        print(<span class="string">'&#123;&#125; consume &#123;&#125;'</span>.format(current_process().name, conn.recv()))</span><br><span class="line">        time.sleep(random.random())</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    pipe = Pipe()</span><br><span class="line">    p1 = Process(target=produce, args=(pipe[<span class="number">0</span>],))</span><br><span class="line">    p2 = Process(target=consume, args=(pipe[<span class="number">1</span>],))</span><br><span class="line">    p1.start()</span><br><span class="line">    p2.start()</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    运行结果如下</span></span><br><span class="line"><span class="string">    Process-1 produce 24</span></span><br><span class="line"><span class="string">    Process-2 consume 24</span></span><br><span class="line"><span class="string">    Process-1 produce 95</span></span><br><span class="line"><span class="string">    Process-2 consume 95</span></span><br><span class="line"><span class="string">    Process-1 produce 100</span></span><br><span class="line"><span class="string">    Process-2 consume 100</span></span><br><span class="line"><span class="string">    Process-1 produce 28</span></span><br><span class="line"><span class="string">    Process-2 consume 28</span></span><br><span class="line"><span class="string">    Process-1 produce 62</span></span><br><span class="line"><span class="string">    Process-2 consume 62</span></span><br><span class="line"><span class="string">    Process-1 produce 92</span></span><br><span class="line"><span class="string">    Process-2 consume 92</span></span><br><span class="line"><span class="string">    ....................</span></span><br><span class="line"><span class="string">    '''</span></span><br></pre></td></tr></table></figure>

<p>上面使用了<code>pipe</code>来实现生产消费模式。</p>
<p>总结<code>Queue</code>与<code>pipe</code>之间的差别如下</p>
<ul>
<li><code>Queue</code>使用<code>put get</code>来维护队列，<code>pipe</code>使用<code>send recv</code>来维护队列 </li>
<li><code>pipe</code>只提供两个端点，而<code>Queue</code>没有限制。这就表示使用<code>pipe</code>时只能同时开启两个进程，可以像上面一样，一个生产者一个消费者，它们分别对这两个端点（<code>Pipe()</code>返回的两个值）操作，两个端点共同维护一个队列。如果多个进程对<code>pipe</code>的同一个端点同时操作，就会发生错误（因为没有上锁，类似线程不安全）。所以两个端点就相当于只提供两个进程安全的操作位置，以此限制了进程数量只能是2 </li>
<li><code>Queue</code>的封装更好，<code>Queue</code>只提供一个结果，它可以被很多进程同时调用；而<code>Pipe()</code>返回两个结果，要分别被两个进程调用</li>
<li><code>Queue</code>的实现基于<code>pipe</code>，所以<code>pipe</code>的运行速度比<code>Queue</code>快很多</li>
<li>当只需要两个进程时使用<code>pipe</code>更快，当需要多个进程同时操作队列时，使用<code>Queue</code> </li>
</ul>
<br/>



<p>3.8、value</p>
<p> 当我们不是想维护一个队列，而只是多个进程同时操作一个数字，就需要提供一个可以在多个进程之间共享的方法，即<code>Value</code> </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process, Value</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f1</span><span class="params">(n)</span>:</span></span><br><span class="line">    n.value += <span class="number">1</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f2</span><span class="params">(n)</span>:</span></span><br><span class="line">    n.value -= <span class="number">2</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    num = Value(<span class="string">'d'</span>, <span class="number">0.0</span>)</span><br><span class="line">    p1 = Process(target=f1, args=(num, ))</span><br><span class="line">    p2 = Process(target=f2, args=(num, ))</span><br><span class="line">    p1.start()</span><br><span class="line">    p2.start()</span><br><span class="line">    p1.join()</span><br><span class="line">    p2.join()</span><br><span class="line">    print(num.value)</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    运行结果如下</span></span><br><span class="line"><span class="string">    -1.0</span></span><br><span class="line"><span class="string">    '''</span></span><br></pre></td></tr></table></figure>



<p>其中<code>Value(&#39;d&#39;, 0.0)</code>中的<code>d</code>表示双精度浮点数，更多类型可以看<a href="https://link.zhihu.com/?target=https%3A//docs.python.org/3.6/library/multiprocessing.html%23module-multiprocessing.sharedctypes">这里</a>。</p>
<p>除了<code>Value</code>，模块还提供了类似的<code>Array</code>，感兴趣的读者可以去<a href="https://link.zhihu.com/?target=https%3A//docs.python.org/3.6/library/multiprocessing.html%23sharing-state-between-processes">官网</a>查看用法</p>
<br/>



<p>3.9、进程锁</p>
<p>既然变量在进程之间可以共享了，那么同时操作一个变量导致的不安全也随之出现。同多线程一样，进程也是通过锁来解决，而且使用方法都和多线程里相同。 </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">lock = multiprocessing.Lock()</span><br><span class="line">lock.acquire()</span><br><span class="line">lock.release()</span><br><span class="line"><span class="keyword">with</span> lock:</span><br></pre></td></tr></table></figure>

<p>这些用法和功能都和多线程是一样的</p>
<p>另外，<code>multiprocessing.Semaphore Condition Event RLock</code>也和多线程相同</p>
<br/>

<br/>

<h3 id="（2）、多线程"><a href="#（2）、多线程" class="headerlink" title="（2）、多线程"></a>（2）、多线程</h3><p>进程可以简单的理解为一个可以独立运行的程序单位，它是线程的集合，进程就是有一个或多个线程构成的。而线程是进程中的实际运行单位，是操作系统进行运算调度的最小单位。可理解为<strong>线程</strong>是进程中的一个最小运行单位。多线程就是指一个进程中同时又多个线程正在执行</p>
<p>多线程是多个任务同时运行的一种方式。比如一个循环中，每个循环看做一个任务，我们希望第一次循环运行还没结束时，就可以开始第二次循环，用这种方式来节省时间。 </p>
<p>1、简单使用</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread <span class="comment"># 多线程</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">myfun</span><span class="params">()</span>:</span></span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line">    a = <span class="number">1</span> + <span class="number">1</span></span><br><span class="line">    print(a)</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="comment"># 不使用多线程</span></span><br><span class="line">t1 = time.time()</span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">    myfun()</span><br><span class="line">print(time.time() - t1)</span><br><span class="line"><span class="comment"># 5s左右</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用多线程</span></span><br><span class="line">t2 = time.time()</span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">    th = Thread(target = myfun)</span><br><span class="line">    th.start()</span><br><span class="line">print(time.time() - t2)</span><br><span class="line"><span class="comment"># 1s左右</span></span><br></pre></td></tr></table></figure>

<p>这里多线程只包括了两步</p>
<ul>
<li><p>用<code>Thread</code>增加一个线程，这里是将每一次循环作为一次新的线程，一个线程执行一次<code>myfun</code>函数 </p>
</li>
<li><p>用<code>start()</code>开始运行这个线程，每个线程都需要这样显式开启才会运行。一个线程这样开启后，不需要等待它运行完成，就可以继续运行下面的程序，即下一次循环（然后又新建了第二个线程，运行未结束即开启第三个……） </p>
<p>这里要注意一点：多线程是放在循环里面的，不能定义好循环之后，从外面将它变成多线程。 </p>
</li>
</ul>
<br/>



<p>2、join使用</p>
<p>线程的<code>join()</code>方法表示等这个线程运行完毕，程序再往下运行。我们来看下面的例子 </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用join()</span></span><br><span class="line">t = time.time()</span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">    th = Thread(target = myfun)</span><br><span class="line">    th.start()</span><br><span class="line">    th.join()</span><br><span class="line">print(time.time() - t)</span><br><span class="line"><span class="comment"># 结果为 5.0047078132629395 秒</span></span><br></pre></td></tr></table></figure>



<p>这里<code>start()</code>之后马上<code>join()</code>，表示每一个线程都要运行结束才能进行下一次循环，这样就和没有使用多线程没有区别了。不过如果要计算多线程运行时间却是要用到这个<code>join()</code></p>
<p>我们先看一下不用<code>join()</code>的情况</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"></span><br><span class="line"><span class="comment"># 不使用join()</span></span><br><span class="line">t1 = time.time()</span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">    th = Thread(target = myfun)</span><br><span class="line">    th.start()</span><br><span class="line">print(time.time() - t1)</span><br><span class="line"><span class="comment"># 结果为  0.0009980201721191406 秒</span></span><br></pre></td></tr></table></figure>



<p>它连1秒都没有等，就输出了结果，而且5个2是在打印出这个之后才输出出来的。这是因为<code>print(time.time() - t)</code>是区别于那5次循环线程之外的第6个线程，它不会等待5个线程运行结束就会开始运行。所以这样是无法获得上面5个线程的运行时间的，我们需要用<code>join()</code>等待5个线程都运行结束。 </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"></span><br><span class="line">t = time.time()</span><br><span class="line">ths = []</span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">    th = Thread(target = myfun)</span><br><span class="line">    th.start()</span><br><span class="line">    ths.append(th)</span><br><span class="line"><span class="keyword">for</span> th <span class="keyword">in</span> ths:</span><br><span class="line">    th.join()</span><br><span class="line">print(time.time() - t)</span><br><span class="line"><span class="comment"># 结果为 1.0038363933563232</span></span><br></pre></td></tr></table></figure>



<p>上面定义<code>ths</code>列表存储这些线程，最后用循环确保每一个线程都已经运行完成再计算时间差。</p>
<p><code>join()</code>不只是用于这种情形。当一步代码运行依赖之前代码运行完成时，就要加入<code>join()</code>命令。</p>
<br/>



<p>3、其他</p>
<p><strong>线程名称</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line">print(threading.current_thread().getName())</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">myfun</span><span class="params">()</span>:</span></span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line">    print(threading.current_thread().name)</span><br><span class="line">    a = <span class="number">1</span> + <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">    th = threading.Thread(target = myfun, name = <span class="string">'thread &#123;&#125;'</span>.format(i))</span><br><span class="line">    th.start()</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="string">'''  </span></span><br><span class="line"><span class="string">输出结果</span></span><br><span class="line"><span class="string">MainThread</span></span><br><span class="line"><span class="string">thread 0</span></span><br><span class="line"><span class="string">thread 1</span></span><br><span class="line"><span class="string">thread 4</span></span><br><span class="line"><span class="string">thread 3</span></span><br><span class="line"><span class="string">thread 2</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>



<p> 解释一下</p>
<ul>
<li><code>threading.current_thread()</code>表示当前线程，可以调用<code>name</code>或<code>getName()</code>获取线程名称 </li>
<li>任何进程都会默认启动一个线程，默认名称为<code>MainThread</code>，也就是主程序占一个线程，这个线程和之后用<code>Thread</code>新加的线程是相互独立的，主线程不会等待其余线程运行结束就会继续往下运行。之前不用<code>join()</code>无法计算运行时间就是因为主线程先运行完了 </li>
<li><code>Thread</code>表示运行这个函数启动一个新的线程，在其中加一个<code>name</code>参数指定这个函数线程名，则在这个函数内打印线程名就显示这里<code>name</code>参数对应值 </li>
<li>在循环中打印有两种。第一种<code>print(threading.current_thread().name)</code>则是<code>MainThread</code>；第二种<code>print(th.name)</code>则是<code>thread 1</code>等 </li>
</ul>
<br/>

<p><strong>Thread函数</strong></p>
<p> 上面我们使用了Thread函数的<code>target name</code>参数，下面来说一下它的其他参数 </p>
<ul>
<li><code>args</code>指定<code>target</code>对应函数的参数，用元组传入，比如<code>args = (3, )</code> </li>
<li><code>daemon</code>主线程默认是<code>False</code>，如果没有指定则继承父线程的值。<code>True</code>则如果主线程运行结束，该线程也停止运行；<code>False</code>则该线程会继续运行直到运行结束，无视主线程如何。（要看这个参数的效果要在py文件中编写代码，在cmd里运行，不能在jupyter notebook里，因为这里会多出一些线程干扰） </li>
<li><code>group</code>是预留的一个参数，用于以后扩展<code>ThreadGroup</code>类，现在没用 </li>
</ul>
<br/>



<p><strong>Thread对象</strong></p>
<p>上面<code>threading.Thread</code>和<code>threading.current_thread()</code>都创建了一个Thread对象，Thread对象有如下属性和方法 </p>
<ul>
<li><code>getName() .name</code> 获取线程名 </li>
<li><code>setName()</code> 设置线程名 </li>
<li><code>start() join()</code>这两个之前说过了 </li>
<li><code>join()</code>有一个<code>timeout</code>参数，表示等待这个线程结束时，如果等待时间超过这个时间，就不再等，继续进行下面的代码，但是这个线程不会被中断 </li>
<li><code>run()</code> 也是运行这个线程，但是必须等到这个线程运行结束才会继续执行之后的代码（如果将上面的<code>start</code>全换成<code>run</code>则相当于没有开多线程） </li>
<li><code>is_alive()</code>如果该线程还没运行完，就是<code>True</code>否则<code>False</code> </li>
<li><code>daemon</code> 返回该线程的<code>daemon</code> </li>
<li><code>setDaemon(True)</code>设置线程的<code>daemon</code> </li>
</ul>
<p>这里有些对象上面多进程有讲到，这里只是再次巩固下记忆</p>
<br/>



<p><strong>threading</strong></p>
<p>一些直接调用的变量</p>
<ul>
<li><code>threading.currentThread()</code>: 返回当前的线程变量 </li>
<li><code>threading.enumerate()</code>: 返回一个包含正在运行的线程的list </li>
<li><code>threading.activeCount()</code>: 返回正在运行的线程数量，与<code>len(threading.enumerate())</code>有相同的结果 </li>
</ul>
<br/>

<br/>

<h3 id="（3）、多进程与多线程的选择和区别"><a href="#（3）、多进程与多线程的选择和区别" class="headerlink" title="（3）、多进程与多线程的选择和区别"></a>（3）、多进程与多线程的选择和区别</h3><p><strong>选择</strong></p>
<p>下面是本人从<a href="https://www.zhihu.com/question/19901763/answer/13299543" target="_blank" rel="noopener">知乎pansz</a>上转载的一个答案，非常通俗地回答了这个问题</p>
<ul>
<li><p>单进程单线程：一个人在一个桌子上吃饭</p>
</li>
<li><p>单进程多线程：多个人在同一个桌子上一起吃饭</p>
</li>
<li><p>多进程单线程：多个人每个人在自己的桌子上吃饭</p>
</li>
</ul>
<p>多线程的问题是多个人同时吃一道菜的时候容易发生争抢，例如两个人同时夹一个菜，一个人刚伸出筷子，结果伸到的时候已经被夹走菜了……此时就必须等一个人夹一口之后，在还给另外一个人夹菜，<strong>也就是说资源共享就会发生冲突争抢</strong></p>
<p>1、对于 Windows 系统来说，【开桌子】的开销很大，因此 Windows 鼓励大家在一个桌子上吃菜。<strong>因此 Windows 多线程学习重点是要大量面对资源争抢与同步方面的问题</strong></p>
<p>2、 对于 Linux 系统来说，【开桌子】的开销很小，因此 Linux 鼓励大家尽量每个人都开自己的桌子吃菜。这带来新的问题是：坐在两张不同的桌子上，说话不方便。<strong>因此Linux 下的学习重点大家要学习进程间通讯的方法</strong></p>
<blockquote>
<p>开桌子的意思是指<strong>创建进程。</strong>开销这里主要指的是<strong>时间开销。</strong><br>可以做个实验：创建一个进程，在进程中往内存写若干数据，然后读出该数据，然后退出。此过程重复 1000 次，相当于创建/销毁进程 1000 次。在我机器上的测试结果是：<br>UbuntuLinux：耗时 0.8 秒 Windows7：耗时 79.8 秒 两者开销大约相差一百倍。<br>这意味着，在 Windows 中，进程创建的开销不容忽视。换句话说就是，Windows 编程中不建议你创建进程，如果你的程序架构需要大量创建进程，那么最好是切换到 Linux 系统。 </p>
</blockquote>
<p>大量创建进程的典型例子有两个，一个是 <strong>gnu autotools 工具链</strong>，用于编译很多开源代码的，他们在 Windows 下编译速度会很慢，因此软件开发人员最好是避免使用 Windows。另一个是<strong>服务器</strong>，某些服务器框架依靠大量创建进程来干活，甚至是对每个用户请求就创建一个进程，这些服务器在 Windows 下运行的效率就会很差。这”可能”也是放眼全世界范围，Linux 服务器远远多于 Windows 服务器的原因。</p>
<blockquote>
<p>再次补充：如果你是写服务器端应用的，其实在现在的网络服务模型下，开桌子的开销是可以忽略不计的，因为现在一般流行的是按照 CPU 核心数量开进程或者线程，开完之后在数量上一直保持，进程与线程内部使用协程或者异步通信来处理多个并发连接，因而开进程与开线程的开销可以忽略了。<br>另外一种新的开销被提上日程：核心切换开销。 现代的体系，一般 CPU 会有多个核心，而多个核心可以同时运行多个不同的线程或者进程。当每个 CPU 核心运行一个进程的时候，由于每个进程的资源都独立，所以 CPU 核心之间切换的时候无需考虑上下文。 当每个 CPU 核心运行一个线程的时候，由于每个线程需要共享资源，所以这些资源必须从 CPU 的一个核心被复制到另外一个核心，才能继续运算，这占用了额外的开销。换句话说，在 CPU 为多核的情况下，多线程在性能上不如多进程。<br>因而，当前面向多核的服务器端编程中，需要习惯多进程而非多线程。 </p>
</blockquote>
<br/>



<p><strong>区别</strong></p>
<p><img src="https://raw.githubusercontent.com/Yzzz011125/Yzzz011125.github.io/master/img/PythonSpider-image/Thread.png" alt=""></p>
<br/>

<br/>



<h3 id="（4）、并行、并发、高并发等概念"><a href="#（4）、并行、并发、高并发等概念" class="headerlink" title="（4）、并行、并发、高并发等概念"></a>（4）、并行、并发、高并发等概念</h3><p><strong>并行</strong>：多个CPU实例或多台机器同时执行一段处理逻辑，是真正的同时。</p>
<p><strong>并发</strong>：通过CPU调度算法，让用户看上去同时执行，实际上CPU操作层面不是真正的同时。</p>
<p>并发时如果操作了公用资源，可能产生线程安全问题。</p>
<p><strong>线程安全</strong>：多个线程操作公用资源，有可能产生安全问题。</p>
<p><strong>高并发</strong>：高并发指的是是一种系统运行过程中遇到的一种“短时间内遇到大量操作请求”的情况，主要发生在web系统集中大量访问或者socket端口集中性收到大量请求（例如：12306的抢票情况；天猫双十一活动）。该情况的发生会导致系统在这段时间内执行大量操作，例如对资源的请求，数据库的操作等。如果高并发处理不好，不仅仅降低了用户的体验度（请求响应时间过长），同时可能导致系统宕机，严重的甚至导致OOM异常，系统停止工作等。如果要想系统能够适应高并发状态，则需要从各个方面进行系统优化，包括，硬件、网络、系统架构、开发语言的选取、数据结构的运用、算法优化、数据库优化……。</p>
<p><strong>多线程与高并发的联系</strong></p>
<p>多线程只是在同/异步角度上解决高并发问题的其中的一个方法手段，是在同一时刻利用计算机闲置资源的一种方式。</p>
<p>多线程在高并发问题中的作用就是充分利用计算机资源，使计算机的资源在每一时刻都能达到最大的利用率，不至于浪费计算机资源使其闲置。</p>

        </div>

        <blockquote class="post-copyright">
    
    <div class="content">
        
<span class="post-time">
    Last updated: <time datetime="2020-05-14T00:45:21.004Z" itemprop="dateUpdated">2020-05-14 08:45:21</time>
</span><br>


        
    </div>
    
    <footer>
        <a href="http://yoursite.com">
            <img src="/img/face.jpg" alt="Yzzz011125">
            Yzzz011125
        </a>
    </footer>
</blockquote>

        
<div class="page-reward">
    <a id="rewardBtn" href="javascript:;" class="page-reward-btn waves-effect waves-circle waves-light">赏</a>
</div>



        <div class="post-footer">
            
	<ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Python/" rel="tag">Python</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Python%E7%88%AC%E8%99%AB/" rel="tag">Python爬虫</a></li></ul>


            
<div class="page-share-wrap">
    

<div class="page-share" id="pageShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=http://yoursite.com/2020/02/10/Python%E5%A4%9A%E8%BF%9B%E7%A8%8B%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B/&title=《Python多进程与多线程》 — Yzzz011125's Blog&pic=http://yoursite.com/img/face.jpg" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=http://yoursite.com/2020/02/10/Python%E5%A4%9A%E8%BF%9B%E7%A8%8B%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B/&title=《Python多进程与多线程》 — Yzzz011125's Blog&source=" data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=http://yoursite.com/2020/02/10/Python%E5%A4%9A%E8%BF%9B%E7%A8%8B%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B/" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《Python多进程与多线程》 — Yzzz011125's Blog&url=http://yoursite.com/2020/02/10/Python%E5%A4%9A%E8%BF%9B%E7%A8%8B%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B/&via=http://yoursite.com" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=http://yoursite.com/2020/02/10/Python%E5%A4%9A%E8%BF%9B%E7%A8%8B%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B/" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>



    <a href="javascript:;" id="shareFab" class="page-share-fab waves-effect waves-circle">
        <i class="icon icon-share-alt icon-lg"></i>
    </a>
</div>



        </div>
    </div>

    
<nav class="post-nav flex-row flex-justify-between flex-row-reverse">
  

  
    <div class="waves-block waves-effect next">
      <a href="/2020/02/08/Python%E7%88%AC%E8%99%AB%E7%9F%A5%E8%AF%86%E7%82%B9/" id="post-next" class="post-nav-link">
        <div class="tips">Next <i class="icon icon-angle-right icon-lg icon-pl"></i></div>
        <h4 class="title">Python爬虫知识点</h4>
      </a>
    </div>
  
</nav>



    











    <!-- Valine Comments -->
    <div class="comments vcomment" id="comments"></div>
    <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
    <script src="//unpkg.com/valine@latest/dist/Valine.min.js"></script>
    <!-- Valine Comments script -->
    <script>
        var GUEST_INFO = ['nick','mail','link'];
        var guest_info = 'nick,mail,link'.split(',').filter(function(item){
          return GUEST_INFO.indexOf(item) > -1
        });
        new Valine({
            el: '#comments',
            notify: 'true' == 'true',
            verify: 'false' == 'true',
            appId: "K86Foqz4aO6SPYTonyVuSX3g-9Nh9j0Va",
            appKey: "g9kSambqKIawCBSmCsGo4upP",
            avatar: "mm",
            placeholder: "Just do it",
            guest_info: guest_info.length == 0 ? GUEST_INFO : guest_info,
            pageSize: "10"
        })
    </script>
    <!-- Valine Comments end -->










</article>

<div id="reward" class="page-modal reward-lay">
    <a class="close" href="javascript:;"><i class="icon icon-close"></i></a>
    <h3 class="reward-title">
        <i class="icon icon-quote-left"></i>
        谢谢老板~
        <i class="icon icon-quote-right"></i>
    </h3>
    <div class="reward-content">
        
        <div class="reward-code">
            <img id="rewardCode" src="/img/wechat.jpg" alt="打赏二维码">
        </div>
        
    </div>
</div>



</div>

        <footer class="footer">
    <div class="top">
        

        <p>
            
            <span>This blog is licensed under a <a rel="license noopener" href="https://creativecommons.org/licenses/by/4.0/" target="_blank">Creative Commons Attribution 4.0 International License</a>.</span>
        </p>
    </div>
    <div class="bottom">
        <p><span>Yzzz011125 &copy; 2019 - 2020</span>
            <span>
                
                Power by <a href="http://hexo.io/" target="_blank">Hexo</a> Theme <a href="https://github.com/yscoder/hexo-theme-indigo" target="_blank">indigo</a>
            </span>
        </p>
    </div>
</footer>

    </main>
    <div class="mask" id="mask"></div>
<a href="javascript:;" id="gotop" class="waves-effect waves-circle waves-light"><span class="icon icon-lg icon-chevron-up"></span></a>



<div class="global-share" id="globalShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=http://yoursite.com/2020/02/10/Python%E5%A4%9A%E8%BF%9B%E7%A8%8B%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B/&title=《Python多进程与多线程》 — Yzzz011125's Blog&pic=http://yoursite.com/img/face.jpg" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=http://yoursite.com/2020/02/10/Python%E5%A4%9A%E8%BF%9B%E7%A8%8B%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B/&title=《Python多进程与多线程》 — Yzzz011125's Blog&source=" data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=http://yoursite.com/2020/02/10/Python%E5%A4%9A%E8%BF%9B%E7%A8%8B%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B/" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《Python多进程与多线程》 — Yzzz011125's Blog&url=http://yoursite.com/2020/02/10/Python%E5%A4%9A%E8%BF%9B%E7%A8%8B%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B/&via=http://yoursite.com" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=http://yoursite.com/2020/02/10/Python%E5%A4%9A%E8%BF%9B%E7%A8%8B%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B/" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>


<div class="page-modal wx-share" id="wxShare">
    <a class="close" href="javascript:;"><i class="icon icon-close"></i></a>
    <p>扫一扫，分享到微信</p>
    <img src="//api.qrserver.com/v1/create-qr-code/?data=http://yoursite.com/2020/02/10/Python%E5%A4%9A%E8%BF%9B%E7%A8%8B%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B/" alt="微信分享二维码">
</div>




    <script src="//cdn.bootcss.com/node-waves/0.7.4/waves.min.js"></script>
<script>
var BLOG = { ROOT: '/', SHARE: true, REWARD: true };


</script>

<script src="//unpkg.com/hexo-theme-material-indigo@latest/js/main.min.js"></script>


<div class="search-panel" id="search-panel">
    <ul class="search-result" id="search-result"></ul>
</div>
<template id="search-tpl">
<li class="item">
    <a href="{path}" class="waves-block waves-effect">
        <div class="title ellipsis" title="{title}">{title}</div>
        <div class="flex-row flex-middle">
            <div class="tags ellipsis">
                {tags}
            </div>
            <time class="flex-col time">{date}</time>
        </div>
    </a>
</li>
</template>

<script src="//unpkg.com/hexo-theme-material-indigo@latest/js/search.min.js" async></script>










</body>
</html>
